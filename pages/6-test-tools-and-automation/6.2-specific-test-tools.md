# Chapter 6: Test Tools and Automation

## 6.2 Specific Test Tools

```markdown
‚úì Date Completed: 18/01/2024 - Understanding Level: üòä
```

- This section contains overview information on tools that are likely to be used by a Technical Test Analyst
  beyond what is discussed in the CTFL syllabus.

- Note that detailed information about tools is provided by the following ISTQB¬Æ syllabi:
  - Mobile Application Testing [CT_MAT_SYL]
  - Performance Testing [CT_PT_SYL]
  - Model-Based Testing [CT_MBT_SYL]
  - Test Automation Engineer [CT_TAE_SYL]

### 6.2.1 Fault Seeding Tools

```markdown
‚úì Date Completed: 18/01/2024 - Understanding Level: üòä
```

- Fault seeding tools modify code to check test coverage.
- They help assess test quality and improve it.
- Typically used by Technical Test Analysts but sometimes by developers for new code testing.

  ```markdown
  // Original JavaScript function
  function add(a, b) {
  return a + b;
  }

  // Mutated version with a defect
  function add(a, b) {
  return a - b; // Intentional defect (mutation)
  }
  ```

### 6.2.2 Fault Injection Tools

```markdown
‚úì Date Completed: 18/01/2024 - Understanding Level: üòä
```

- Fault injection tools intentionally provide incorrect inputs to test software.
- These incorrect inputs create negative conditions to test error handling.
- Disrupting the normal code execution flow also helps increase code coverage.
- Typically used by Technical Test Analysts but sometimes by developers for new code testing.

### 6.2.3 Performance Testing Tools

```markdown
‚úì Date Completed: 18/01/2024 - Understanding Level: üòä
```

- Performance testing tools serve several main functions:

  - Generating load.
  - Providing measurement, monitoring, visualization, and analysis of system responses under load.

- Load generation involves implementing a predefined operational profile as a script.
- The script may initially be captured for a single user (possibly using a capture/playback tool)
- Then it is implemented for the specified operational profile using the performance test tool. It must take into account the variation of data per transaction.

- Performance tools simulate user interactions with the system at the communications protocol level, not necessarily through a graphical user interface.

  - This reduces the need for separate "sessions" during testing.
  - Some tools can also use the application's user interface to measure response times.

- Key metrics and reports generated by performance test tools include:

  - Number of simulated users
  - Number and type of transactions generated
  - Response times for specific transaction requests
  - Load vs. response time graphs
  - Resource usage reports (e.g., usage over time with min and max values)

- Factors to consider when implementing performance test tools:

  - Hardware and network bandwidth requirements
  - Compatibility with the system's communication protocol
  - Flexibility to implement different operational profiles
  - Monitoring, analysis, and reporting capabilities

- Performance test tools are typically acquired rather than developed in-house due to the effort involved.
  - Exceptions may include technical restrictions or simpler load profiles.

### 6.2.4 Tools for Testing Websites

```markdown
‚úì Date Completed: 18/01/2024 - Understanding Level: üòä
```

Common web-based testing tools:

- Hyperlink test tools: Scan for broken or missing hyperlinks.
- HTML and XML checkers: Ensure compliance with HTML and XML standards.
- Performance testing tools: Assess server response under heavy user loads.
- Lightweight automation execution tools: Compatible with various browsers.
- Server code scanning tools: Identify orphaned files previously accessed by the website.
- HTML spell checkers: Detect spelling errors.
- Cascading Style Sheet (CSS) checking tools: Validate CSS.
- Standards violation checkers: Verify compliance with accessibility standards (e.g., Section 508, M/376).
- Security issue scanners: Identify security vulnerabilities.

Sources of open-source web testing tools:

- The World Wide Web Consortium (W3C): Offers tools to check for errors against internet standards.
- The Web Hypertext Application Technology Working Group (WHATWG): Provides HTML validation tools.

Additional information provided by some tools:

- Web spider engines: Offer data on page size, download time, and page availability (e.g., HTTP error 404).

- Usage by Test Analysts and Technical Test Analysts during system testing.

### 6.2.5 Tools to Support Model-Based Testing

```markdown
‚úì Date Completed: 18/01/2024 - Understanding Level: üòä
```

- Model-Based Testing (MBT) uses models (e.g., finite state machines) to describe software behavior.
- Commercial MBT tools offer execution engines to run these models.
- Execution threads from models can be saved as test cases.
- Other executable models like Petri Nets and statecharts also support MBT.
- MBT tools generate diverse execution threads and help reduce possible paths in a model.
- Testing with MBT tools offers a unique perspective on software, uncovering defects missed by functional testing.

### 6.2.6 Component Testing and Build Tools

```markdown
‚úì Date Completed: 18/01/2024 - Understanding Level: üòä
```

- Component testing and build automation tools are used in Agile development and are sometimes managed by Technical Test Analysts.
- Component testing tools are language-specific, such as JUnit for Java, and there are xUnit frameworks for various languages.
- These tools generate test objects for each class, simplifying automation tasks for programmers.
- Some build automation tools can trigger a new build automatically when a component changes, followed by automated component tests.
- This level of automation is common in continuous integration environments.
- Properly configured tools can improve build quality by detecting regression defects early.
- If a programmer's change introduces defects, automated tests will fail, prompting immediate investigation before the build is released for testing.

### 6.2.7 Tools to Support Mobile Application Testing

Emulators and simulators are frequently used tools to support the testing of mobile applications.

#### 6.2.7.1 Simulators

```markdown
‚úì Date Completed: 18/01/2024 - Understanding Level: üòä
```

- Mobile simulators model the runtime environment of a mobile platform.
- Applications tested on simulators are compiled into versions that work in the simulator but not on real devices.
- Simulators are used as substitutes for real devices in testing, primarily for initial functional testing and simulating multiple virtual users in load testing.
- Simulators are simpler and faster than emulators but have limitations.
- Applications tested on simulators may differ from the final distributed version.

### 6.2.7.2 Emulators

```markdown
‚úì Date Completed: 18/01/2024 - Understanding Level: üòä
```

- Mobile emulators model both the hardware and runtime environment of the physical hardware.
- Applications compiled for emulators can also be used on real devices.
- Emulators cannot fully replace real devices as they may behave differently and lack support for certain features like multi-touch and accelerometers.
- Limitations of the emulator's platform can contribute to these differences.

### 6.2.7.3 Common Aspects

```markdown
‚úì Date Completed: 18/01/2024 - Understanding Level: üòä
```

- Simulators and emulators are used to replace real devices, reducing test environment costs.
- They are particularly useful in the early stages of development, integrating with development environments and enabling quick deployment, testing, and monitoring of applications.
- Emulators and simulators require launching, app installation, and testing, mimicking real device usage.
- Each mobile operating system development environment typically includes its own bundled emulator or simulator.
- Third-party emulators and simulators are also available.
- Emulators and simulators often allow the configuration of various usage parameters, such as network emulation, signal strength, orientation, interrupts, and GPS location data.
- Some of these settings are valuable for replicating difficult or costly scenarios that are hard to achieve with real devices, like global GPS positions or signal strengths.

---

[‚Üë Table of Contents](../../README.md#table-of-contents) | [‚Üê Previous Page](../5-reviews/5.2-using-checklists-in-reviews.md)
